<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Physik-Spiel Prototyp â€“ 5er-Linien (Magnetismus) v7</title>
  <style>
    :root{
      --panel: rgba(17,24,39,.92);
      --border: rgba(148,163,184,.22);
      --text:#e5e7eb;
      --muted:#94a3b8;
      --shadow: 0 22px 70px rgba(0,0,0,.65);
    }
    *{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:12px;
      background:
        radial-gradient(circle at 15% 10%, rgba(56,189,248,.18), transparent 55%),
        radial-gradient(circle at 85% 15%, rgba(34,197,94,.12), transparent 58%),
        radial-gradient(circle at 80% 90%, rgba(239,68,68,.14), transparent 58%),
        linear-gradient(180deg, #0b1220, #020617);
      color:var(--text);
      overflow:hidden;
    }
    .app{
      width:min(460px, 100%);
      height:min(860px, 100dvh);
      background: var(--panel);
      border:1px solid var(--border);
      border-radius:22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .top{padding:12px 12px 10px;border-bottom:1px solid rgba(148,163,184,.16);}
    .brand{font-size:.75rem; letter-spacing:.18em; text-transform:uppercase; color:rgba(148,163,184,.95);}
    h1{font-size:1.1rem; margin-top:4px; font-weight:900;}
    .sub{margin-top:6px; color:var(--muted); font-size:.90rem; line-height:1.35;}
    .wordRow{margin-top:10px;display:flex;gap:6px;justify-content:center;align-items:center;flex-wrap:wrap;}
    .letter{
      width:24px; height:24px;border-radius:8px;
      display:flex; align-items:center; justify-content:center;
      font-weight:900;background: rgba(2,6,23,.40);
      border:1px solid rgba(148,163,184,.18);
      color: rgba(229,231,235,.9);
    }
    .letter.on{
      background: linear-gradient(135deg, rgba(56,189,248,.95), rgba(251,191,36,.95));
      border-color: rgba(248,250,252,.55);
      color:#0b1220;
      box-shadow: 0 10px 30px rgba(56,189,248,.18);
    }
    .wordBtn{
      border:none;border-radius:999px;padding:.48rem .8rem;
      font-weight:900;letter-spacing:.08em;text-transform:uppercase;
      background: linear-gradient(135deg, rgba(251,191,36,.95), rgba(56,189,248,.95));
      color:#0b1220;box-shadow: 0 14px 40px rgba(56,189,248,.18);
      cursor:pointer;
    }

    .game{padding:10px 12px 14px;display:flex;flex-direction:column;gap:10px;flex:1;min-height:0;}
    .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .pill{
      border:1px solid rgba(148,163,184,.22);background: rgba(2,6,23,.34);
      border-radius:999px;padding:.30rem .6rem;font-size:.88rem;
      color: rgba(229,231,235,.95);display:inline-flex;gap:.45rem;align-items:center;white-space:nowrap;
    }
    .pill b{color: rgba(251,191,36,.95)}

    .gridWrap{
      flex:1;min-height:0;display:flex;align-items:center;justify-content:center;
      padding:8px;border-radius:18px;background: rgba(2,6,23,.32);
      border:1px solid rgba(148,163,184,.16);
    }
    canvas{
      width:100%;height:100%;max-height: 60dvh;display:block;
      border-radius:14px;background: rgba(15,23,42,.55);
      border:1px solid rgba(148,163,184,.14);
      touch-action: none;outline:none;
    }

    .hint{text-align:center;color: var(--muted);font-size:.92rem;line-height:1.35;padding-top:6px;display:flex;flex-direction:column;gap:6px;align-items:center;justify-content:center;}
    .gestures{display:flex;gap:10px;align-items:center;justify-content:center;flex-wrap:wrap;opacity:.95;}
    .gesture{display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.20);background: rgba(2,6,23,.30);font-weight:900;color: rgba(229,231,235,.92);white-space:nowrap;}
    .gesture .ic{width:26px;height:26px;border-radius:10px;display:flex;align-items:center;justify-content:center;background: rgba(148,163,184,.14);}

    .startOverlay{position:fixed; inset:0;display:flex;align-items:center;justify-content:center;padding:16px;background: rgba(0,0,0,.55);z-index: 50;}
    .startCard{width:min(520px, 100%);background: rgba(2,6,23,.92);border:1px solid rgba(148,163,184,.28);border-radius:22px;box-shadow: var(--shadow);padding:16px;text-align:center;}
    .startCard h2{margin:0 0 6px;font-size:1.15rem;font-weight:1000;}
    .startCard p{margin:0 0 12px;color: rgba(148,163,184,.95);line-height:1.35;}
    .bigBtn{border:none;border-radius:999px;padding:.75rem 1.1rem;font-weight:1000;letter-spacing:.08em;text-transform:uppercase;background: linear-gradient(135deg, rgba(251,191,36,.95), rgba(56,189,248,.95));color:#0b1220;cursor:pointer;}

    .modalOverlay{position:fixed; inset:0;background: rgba(0,0,0,.62);display:none;align-items:center;justify-content:center;padding:16px;z-index:999;}
    .modalOverlay.show{display:flex;}
    .modal{width:min(520px, 100%);background: rgba(2,6,23,.94);border:1px solid rgba(148,163,184,.28);border-radius:20px;box-shadow: var(--shadow);padding:14px;}
    .modal h2{font-size:1.02rem;letter-spacing:.12em;text-transform:uppercase;color: rgba(148,163,184,.95);margin-bottom:8px;}
    .q{font-size:1.0rem;font-weight:900;line-height:1.45;margin-bottom:10px;}
    .answers{display:grid; gap:10px;}
    .ans{width:100%;text-align:left;border-radius:16px;padding:.72rem .82rem;border:1px solid rgba(148,163,184,.22);background: rgba(15,23,42,.45);color: var(--text);font-weight:900;cursor:pointer;}
    .ans.good{border-color: rgba(34,197,94,.55);background: rgba(34,197,94,.10);}
    .ans.bad{border-color: rgba(239,68,68,.55);background: rgba(239,68,68,.10);}
    .modalFoot{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;color: rgba(229,231,235,.95);font-weight:900;}
    .status.good{color: #22c55e;}
    .status.bad{color: #ef4444;}
    .closeBtn{border:none;border-radius:999px;padding:.5rem .85rem;font-weight:900;background: rgba(148,163,184,.16);color: var(--text);cursor:pointer;}
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="brand">Physik App Â· Probespiel Â· 5er-Linien</div>
      <h1>Level 1: Magnetismus</h1>
      <div class="sub"><b>Regel:</b> 5 gleiche Blasen in einer Linie = âœ… â†’ <b>1 Buchstabe</b>. (Waagerecht + Senkrecht + Diagonal.)</div>
      <div class="wordRow" id="wordRow"></div>
    </div>

    <div class="game">
      <div class="hud">
        <div class="pill">Buchstaben: <b id="rowsText">0</b>/11</div>
        <div class="pill">Spalten: <b id="colsText">8</b></div>
        <div class="pill">Linie: <b>5</b></div>
      </div>

      <div class="gridWrap">
        <canvas id="cv" width="360" height="600" aria-label="Spiel"></canvas>
      </div>

      <div class="hint">
        <div class="gestures">
          <div class="gesture"><span class="ic">ðŸ‘ˆðŸ‘‰</span></div>
          <div class="gesture"><span class="ic">ðŸ‘‡</span></div>
          <div class="gesture"><span class="ic">ðŸ‘†</span></div>
        </div>
      </div>
    </div>
  </div>

  <div class="startOverlay" id="startOverlay">
    <div class="startCard">
      <h2>Startbereit?</h2>
      <p>Ziel: Sammle Buchstaben fÃ¼r <b>MAGNETISMUS</b> durch 5er-Linien gleicher Blasen.</p>
      <button class="bigBtn" id="startBtn" type="button">Start</button>
    </div>
  </div>

  <div class="modalOverlay" id="modal">
    <div class="modal" role="dialog" aria-modal="true">
      <h2>MAGNETISMUS</h2>
      <div class="q">Welche Aussage beschreibt Magnetismus am besten?</div>
      <div class="answers" id="answers"></div>
      <div class="modalFoot">
        <div class="status" id="status">WÃ¤hle eine Antwort.</div>
        <button class="closeBtn" id="closeBtn" type="button">SchlieÃŸen</button>
      </div>
    </div>
  </div>

  <script>
    const COLS = 8;              // full width is usable (no dead space)
    const ROWS = 10;
    const LINE = 5;
    const TARGET = "MAGNETISMUS";
    const ALLOW_DIAGONAL = true;

    // No letters (cosmetic): simple physics icons + some plain bubbles
    const BUBBLES = [
      {id:"MAG", icon:"ðŸ§²", hue: 145},
      {id:"ELE", icon:"âš¡", hue: 48},
      {id:"LIG", icon:"ðŸ’¡", hue: 35},
      {id:"BAT", icon:"ðŸ”‹", hue: 115},
      {id:"PL1", icon:"",   hue: 210},
      {id:"PL2", icon:"",   hue: 265},
    ];

    const QUESTIONS = {
      answers: [
        {t:"Magnetismus ist die Anziehung aller Metalle.", ok:false},
        {t:"Magnetismus ist eine Kraftwirkung zwischen bestimmten Stoffen â€“ auch ohne BerÃ¼hrung.", ok:true},
        {t:"Magnetismus entsteht nur, wenn Strom flieÃŸt.", ok:false},
        {t:"Magnetismus ist Reibung, die WÃ¤rme erzeugt.", ok:false},
      ],
      hint: "Wink: â€žKrÃ¤fte ohne BerÃ¼hrungâ€œ und nicht alle Metalle werden angezogen."
    };

    const cv = document.getElementById("cv");
    const ctx = cv.getContext("2d");
    const rowsText = document.getElementById("rowsText");
    document.getElementById("colsText").textContent = String(COLS);
    const wordRow = document.getElementById("wordRow");

    const startOverlay = document.getElementById("startOverlay");
    const startBtn = document.getElementById("startBtn");

    const modal = document.getElementById("modal");
    const answersEl = document.getElementById("answers");
    const statusEl = document.getElementById("status");
    const closeBtn = document.getElementById("closeBtn");

    let grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => null));

    // current piece uses smooth y (float rows) -> smooth fall
    let current = null; // {col:int, y:float, bubble}
    let letters = 0;
    let pausedForQuestion = false;
    let running = false;

    let softDrop = false;
    let lastTs = 0;

    // clearing highlight
    let clearingCells = new Set();
    let clearUntilTs = 0;

    function randBubble(){
      return BUBBLES[Math.floor(Math.random()*BUBBLES.length)];
    }

    function renderWord(){
      wordRow.innerHTML = "";
      for(let i=0;i<TARGET.length;i++){
        const d = document.createElement("div");
        d.className = "letter" + (i < letters ? " on" : "");
        d.textContent = (i < letters) ? TARGET[i] : "";
        wordRow.appendChild(d);
      }
      if(letters >= TARGET.length){
        const b = document.createElement("button");
        b.className = "wordBtn";
        b.textContent = TARGET;
        b.addEventListener("click", openQuestion);
        wordRow.appendChild(b);
      }
      rowsText.textContent = String(letters);
    }
    renderWord();

    function resizeCanvasToDisplay(){
      const rect = cv.getBoundingClientRect();
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if(cv.width !== w || cv.height !== h){
        cv.width = w;
        cv.height = h;
      }
    }
    function cellSize(){
      return Math.min(cv.width / COLS, cv.height / ROWS);
    }

    function canOccupy(r,c){
      return r>=0 && r<ROWS && c>=0 && c<COLS && grid[r][c] === null;
    }

    function spawn(){
      const c = Math.floor(COLS/2);
      if(grid[0][c]){ reset("Game Over â€“ Neustart"); return; }
      current = {col: c, y: 0, bubble: randBubble()};
    }

    function lockCurrent(){
      const r = Math.round(current.y);
      grid[r][current.col] = current.bubble;
      current = null;

      const matches = findMatches();
      if(matches.size){
        clearingCells = matches;
        clearUntilTs = performance.now() + 520;
      }else{
        if(!pausedForQuestion) spawn();
      }
    }

    function hardDrop(){
      if(!running || !current || pausedForQuestion || clearingCells.size) return;
      let r = Math.floor(current.y);
      while(true){
        const nr = r + 1;
        if(nr < ROWS && canOccupy(nr, current.col)) r = nr;
        else break;
      }
      current.y = r;
      lockCurrent();
    }

    function setColumnFromX(clientX){
      if(!running || !current || pausedForQuestion || clearingCells.size) return;
      const rect = cv.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width - 1, clientX - rect.left));
      const targetCol = Math.max(0, Math.min(COLS-1, Math.floor((x / rect.width) * COLS)));

      // stepwise slide toward target; stop if blocked
      const rowNow = Math.round(current.y);
      while(current.col < targetCol){
        if(canOccupy(rowNow, current.col + 1)) current.col++;
        else break;
      }
      while(current.col > targetCol){
        if(canOccupy(rowNow, current.col - 1)) current.col--;
        else break;
      }
    }

    // ====== Matching (5 in a line) ======
    function findMatches(){
      const marked = new Set();
      const markCells = (cells) => { for(const [r,c] of cells) marked.add(`${r},${c}`); };

      // horizontal
      for(let r=0;r<ROWS;r++){
        let run=[], lastId=null;
        for(let c=0;c<COLS;c++){
          const id = grid[r][c]?.id ?? null;
          if(id && id===lastId) run.push([r,c]);
          else{
            if(run.length>=LINE) markCells(run);
            run = id ? [[r,c]] : [];
            lastId = id;
          }
        }
        if(run.length>=LINE) markCells(run);
      }

      // vertical
      for(let c=0;c<COLS;c++){
        let run=[], lastId=null;
        for(let r=0;r<ROWS;r++){
          const id = grid[r][c]?.id ?? null;
          if(id && id===lastId) run.push([r,c]);
          else{
            if(run.length>=LINE) markCells(run);
            run = id ? [[r,c]] : [];
            lastId = id;
          }
        }
        if(run.length>=LINE) markCells(run);
      }

      if(ALLOW_DIAGONAL){
        // diag down-right (\)
        for(let sr=0; sr<ROWS; sr++){
          let r=sr,c=0,run=[],lastId=null;
          while(r<ROWS && c<COLS){
            const id = grid[r][c]?.id ?? null;
            if(id && id===lastId) run.push([r,c]);
            else{
              if(run.length>=LINE) markCells(run);
              run = id ? [[r,c]] : [];
              lastId = id;
            }
            r++; c++;
          }
          if(run.length>=LINE) markCells(run);
        }
        for(let sc=1; sc<COLS; sc++){
          let r=0,c=sc,run=[],lastId=null;
          while(r<ROWS && c<COLS){
            const id = grid[r][c]?.id ?? null;
            if(id && id===lastId) run.push([r,c]);
            else{
              if(run.length>=LINE) markCells(run);
              run = id ? [[r,c]] : [];
              lastId = id;
            }
            r++; c++;
          }
          if(run.length>=LINE) markCells(run);
        }

        // diag down-left (/)
        for(let sr=0; sr<ROWS; sr++){
          let r=sr,c=COLS-1,run=[],lastId=null;
          while(r<ROWS && c>=0){
            const id = grid[r][c]?.id ?? null;
            if(id && id===lastId) run.push([r,c]);
            else{
              if(run.length>=LINE) markCells(run);
              run = id ? [[r,c]] : [];
              lastId = id;
            }
            r++; c--;
          }
          if(run.length>=LINE) markCells(run);
        }
        for(let sc=COLS-2; sc>=0; sc--){
          let r=0,c=sc,run=[],lastId=null;
          while(r<ROWS && c>=0){
            const id = grid[r][c]?.id ?? null;
            if(id && id===lastId) run.push([r,c]);
            else{
              if(run.length>=LINE) markCells(run);
              run = id ? [[r,c]] : [];
              lastId = id;
            }
            r++; c--;
          }
          if(run.length>=LINE) markCells(run);
        }
      }

      return marked;
    }

    function applyClear(){
      if(!clearingCells.size) return;

      for(const key of clearingCells){
        const [rS,cS] = key.split(",");
        grid[+rS][+cS] = null;
      }

      // gravity
      for(let c=0;c<COLS;c++){
        const stack=[];
        for(let r=ROWS-1;r>=0;r--) if(grid[r][c]) stack.push(grid[r][c]);
        for(let r=ROWS-1;r>=0;r--) grid[r][c] = stack[ROWS-1-r] || null;
      }

      const gained = Math.max(1, Math.floor(clearingCells.size / LINE));
      letters = Math.min(TARGET.length, letters + gained);
      renderWord();

      clearingCells = new Set();
      if(letters >= TARGET.length) pausedForQuestion = true;
      if(!pausedForQuestion) spawn();
    }

    // ====== Drawing ======
    function drawGrid(){
      const s = cellSize();
      ctx.save();
      ctx.globalAlpha = 0.20;
      ctx.strokeStyle = "rgba(148,163,184,.25)";
      for(let r=0;r<=ROWS;r++){
        ctx.beginPath(); ctx.moveTo(0, r*s); ctx.lineTo(COLS*s, r*s); ctx.stroke();
      }
      for(let c=0;c<=COLS;c++){
        ctx.beginPath(); ctx.moveTo(c*s, 0); ctx.lineTo(c*s, ROWS*s); ctx.stroke();
      }
      ctx.restore();
    }

    function drawBubbleAt(cx, cy, bubble, radius, glow=1, flash=0){
      ctx.save();
      const alpha = 0.55*glow + flash*0.35;
      ctx.shadowColor = `hsla(${bubble.hue}, 95%, 60%, ${alpha})`;
      ctx.shadowBlur = 14*glow + flash*22;

      const g = ctx.createRadialGradient(cx - radius*0.35, cy - radius*0.35, radius*0.2, cx, cy, radius*1.1);
      g.addColorStop(0, `hsla(${bubble.hue}, 95%, ${92 + flash*6}%, 1)`);
      g.addColorStop(0.35, `hsla(${bubble.hue}, 92%, ${60 + flash*8}%, 1)`);
      g.addColorStop(1, `hsla(${bubble.hue}, 92%, 38%, 1)`);

      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.fill();

      ctx.shadowBlur = 0;
      ctx.strokeStyle = "rgba(248,250,252,.35)";
      ctx.lineWidth = Math.max(1, radius*0.06);
      ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.stroke();

      ctx.globalAlpha = 0.28 + flash*0.35;
      ctx.fillStyle = "white";
      ctx.beginPath(); ctx.arc(cx - radius*0.28, cy - radius*0.28, radius*0.22, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;

      if(bubble.icon){
        ctx.fillStyle = "rgba(2,6,23,.92)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `900 ${Math.floor(radius*0.95)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
        ctx.fillText(bubble.icon, cx, cy+1);
      }

      ctx.restore();
    }

    function draw(ts=0){
      resizeCanvasToDisplay();
      ctx.clearRect(0,0,cv.width,cv.height);

      const s = cellSize();
      const radius = s*0.44;

      drawGrid();

      let flash = 0;
      if(clearingCells.size) flash = 0.35 + 0.35*Math.sin(ts/80);

      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const b = grid[r][c];
          if(!b) continue;
          const key = `${r},${c}`;
          const isClearing = clearingCells.has(key);
          const cx = c*s + s/2;
          const cy = r*s + s/2;
          drawBubbleAt(cx, cy, b, radius, isClearing ? 1.35 : 0.85, isClearing ? flash : 0);
        }
      }

      if(current){
        const cx = current.col*s + s/2;
        const cy = current.y*s + s/2;
        drawBubbleAt(cx, cy, current.bubble, radius, 1.15, 0);
      }
    }

    // ====== Question modal ======
    function openQuestion(){
      if(letters < TARGET.length) return;
      answersEl.innerHTML = "";
      statusEl.textContent = "WÃ¤hle eine Antwort.";
      statusEl.className = "status";
      QUESTIONS.answers.forEach(a => {
        const b = document.createElement("button");
        b.className = "ans";
        b.textContent = a.t;
        b.type = "button";
        b.addEventListener("click", () => grade(a.ok, b));
        answersEl.appendChild(b);
      });
      modal.classList.add("show");
    }
    function grade(ok, btn){
      [...answersEl.querySelectorAll("button")].forEach(x => x.disabled = true);
      if(ok){
        btn.classList.add("good");
        statusEl.textContent = "âœ… Richtig! Level abgeschlossen.";
        statusEl.className = "status good";
      }else{
        btn.classList.add("bad");
        statusEl.textContent = "âŒ Falsch. " + QUESTIONS.hint;
        statusEl.className = "status bad";
        setTimeout(() => {
          [...answersEl.querySelectorAll("button")].forEach(x => {
            x.disabled = false;
            x.classList.remove("bad","good");
          });
          statusEl.textContent = "Versuchâ€™s nochmal.";
          statusEl.className = "status";
        }, 950);
      }
    }
    closeBtn.addEventListener("click", () => modal.classList.remove("show"));

    // ====== Input (touch-first) ======
    let startX=0, startY=0;
    let downSwipeActive = false;

    cv.addEventListener("pointerdown", (e) => {
      cv.setPointerCapture(e.pointerId);
      startX = e.clientX;
      startY = e.clientY;
      downSwipeActive = false;
      softDrop = false;
      setColumnFromX(e.clientX); // follow full width immediately
    });

    cv.addEventListener("pointermove", (e) => {
      if(!running || !current || pausedForQuestion || clearingCells.size) return;
      setColumnFromX(e.clientX);
      const dy = e.clientY - startY;
      softDrop = dy > 28;
      downSwipeActive = softDrop;
    });

    cv.addEventListener("pointerup", (e) => {
      const dx = Math.abs(e.clientX - startX);
      const dy = Math.abs(e.clientY - startY);
      const isTap = dx < 10 && dy < 10 && !downSwipeActive;
      softDrop = false;
      downSwipeActive = false;
      if(isTap) hardDrop();
    });

    // ====== Smooth fall physics ======
    function cellsPerSecond(){
      const base = 1.6;                  // smooth base speed (cells/s)
      const bonus = Math.min(0.9, letters*0.08);
      const normal = base + bonus;
      return softDrop ? normal*6.0 : normal;
    }

    function trySetY(yCandidate){
      if(yCandidate >= ROWS-1){
        current.y = ROWS-1;
        lockCurrent();
        return false;
      }

      // if we crossed into a new row, check that cell
      const fromRow = Math.floor(current.y);
      const toRow = Math.floor(yCandidate);
      if(toRow == fromRow){
        current.y = yCandidate;
        return true;
      }

      // entering next row
      if(canOccupy(toRow, current.col)){
        current.y = yCandidate;
        return true;
      }else{
        current.y = fromRow;
        lockCurrent();
        return false;
      }
    }

    function physicsStep(dt){
      if(!running) return;

      if(!current && !pausedForQuestion && !clearingCells.size) spawn();

      if(clearingCells.size){
        if(performance.now() >= clearUntilTs) applyClear();
        return;
      }
      if(!current || pausedForQuestion) return;

      const v = cellsPerSecond();
      let newY = current.y + v*dt;

      // clamp dt and move in small chunks to avoid skipping collisions
      const maxChunk = 0.35; // rows
      while(newY - current.y > maxChunk){
        if(!trySetY(current.y + maxChunk)) return;
      }
      trySetY(newY);
    }

    function loop(ts){
      if(!lastTs) lastTs = ts;
      const dt = Math.min(0.033, (ts - lastTs) / 1000);
      lastTs = ts;

      physicsStep(dt);
      draw(ts);
      requestAnimationFrame(loop);
    }

    function reset(msg){
      grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => null));
      current = null;
      letters = 0;
      pausedForQuestion = false;
      softDrop = false;
      clearingCells = new Set();
      clearUntilTs = 0;
      renderWord();
      if(msg) alert(msg);
    }

    startBtn.addEventListener("click", () => {
      startOverlay.style.display = "none";
      running = true;
    });

    window.addEventListener("resize", () => draw(performance.now()));
    draw(performance.now());
    requestAnimationFrame(loop);
  </script>
</body>
</html>
