<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Physik-Spiel Prototyp â€“ 5er-Linien (Magnetismus) v10</title>
  <style>
    :root{
      --panel: rgba(17,24,39,.92);
      --border: rgba(148,163,184,.22);
      --text:#e5e7eb;
      --muted:#94a3b8;
      --shadow: 0 22px 70px rgba(0,0,0,.65);
    }
    *{box-sizing:border-box;margin:0;padding:0;font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;}
    body{
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;

      min-height:100vh;display:flex;align-items:center;justify-content:center;padding:12px;
      background:
        radial-gradient(circle at 15% 10%, rgba(56,189,248,.18), transparent 55%),
        radial-gradient(circle at 85% 15%, rgba(34,197,94,.12), transparent 58%),
        radial-gradient(circle at 80% 90%, rgba(239,68,68,.14), transparent 58%),
        linear-gradient(180deg, #0b1220, #020617);
      color:var(--text);overflow:hidden;
    }
    .app{
      width:min(460px, 100%);height:min(860px, 100dvh);
      background: rgba(17,24,39,.92);
      border:1px solid var(--border);border-radius:22px;box-shadow: var(--shadow);
      overflow:hidden;display:flex;flex-direction:column;
    }
    .top{padding:12px 12px 10px;border-bottom:1px solid rgba(148,163,184,.16);}
    .brand{font-size:.75rem; letter-spacing:.18em; text-transform:uppercase; color:rgba(148,163,184,.95);}
    h1{font-size:1.1rem; margin-top:4px; font-weight:900;}
    .sub{margin-top:6px; color:var(--muted); font-size:.90rem; line-height:1.35;}
    .wordRow{margin-top:10px;display:flex;gap:6px;justify-content:center;align-items:center;flex-wrap:wrap;}
    .letter{
      width:24px;height:24px;border-radius:8px;display:flex;align-items:center;justify-content:center;
      font-weight:900;background: rgba(2,6,23,.40);border:1px solid rgba(148,163,184,.18);
      color: rgba(229,231,235,.9);
    }
    .letter.on{
      background: linear-gradient(135deg, rgba(56,189,248,.95), rgba(251,191,36,.95));
      border-color: rgba(248,250,252,.55);color:#0b1220;
      box-shadow: 0 10px 30px rgba(56,189,248,.18);
    }
    .wordBtn{
      border:none;border-radius:999px;padding:.48rem .8rem;font-weight:900;letter-spacing:.08em;text-transform:uppercase;
      background: linear-gradient(135deg, rgba(251,191,36,.95), rgba(56,189,248,.95));
      color:#0b1220;box-shadow: 0 14px 40px rgba(56,189,248,.18);cursor:pointer;
    }
    .game{padding:10px 12px 14px;display:flex;flex-direction:column;gap:10px;flex:1;min-height:0;}
    .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .pill{
      border:1px solid rgba(148,163,184,.22);background: rgba(2,6,23,.34);border-radius:999px;
      padding:.30rem .6rem;font-size:.88rem;color: rgba(229,231,235,.95);
      display:inline-flex;gap:.45rem;align-items:center;white-space:nowrap;
    }
    .pill b{color: rgba(251,191,36,.95)}
    .gridWrap{
      flex:1;min-height:0;display:flex;align-items:center;justify-content:center;
      padding:8px;border-radius:18px;background: rgba(2,6,23,.32);border:1px solid rgba(148,163,184,.16);
    }
    canvas{
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;

      width:100%;height:100%;max-height: 60dvh;display:block;border-radius:14px;
      background: rgba(15,23,42,.55);border:1px solid rgba(148,163,184,.14);
      touch-action:none;outline:none;
    }
    .hint{text-align:center;color: var(--muted);font-size:.92rem;line-height:1.35;padding-top:6px;display:flex;flex-direction:column;gap:6px;align-items:center;justify-content:center;}
    .gestures{display:flex;gap:10px;align-items:center;justify-content:center;flex-wrap:wrap;opacity:.95;}
    .gesture{display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid rgba(148,163,184,.20);background: rgba(2,6,23,.30);font-weight:900;color: rgba(229,231,235,.92);white-space:nowrap;}
    .gesture .ic{width:26px;height:26px;border-radius:10px;display:flex;align-items:center;justify-content:center;background: rgba(148,163,184,.14);}

    .startOverlay{position:fixed; inset:0;display:flex;align-items:center;justify-content:center;padding:16px;background: rgba(0,0,0,.55);z-index: 50;}
    .startCard{width:min(520px, 100%);background: rgba(2,6,23,.92);border:1px solid rgba(148,163,184,.28);border-radius:22px;box-shadow: var(--shadow);padding:16px;text-align:center;}
    .startCard h2{margin:0 0 6px;font-size:1.15rem;font-weight:1000;}
    .startCard p{margin:0 0 12px;color: rgba(148,163,184,.95);line-height:1.35;}
    .bigBtn{border:none;border-radius:999px;padding:.75rem 1.1rem;font-weight:1000;letter-spacing:.08em;text-transform:uppercase;background: linear-gradient(135deg, rgba(251,191,36,.95), rgba(56,189,248,.95));color:#0b1220;cursor:pointer;}
    .smallRow{margin-top:10px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    .toggle{
      border:1px solid rgba(148,163,184,.25);background: rgba(15,23,42,.45);
      color: rgba(229,231,235,.95);border-radius:999px;padding:.55rem .85rem;font-weight:900;cursor:pointer;
    }
    .toggle.on{
      border-color: rgba(56,189,248,.55);
      box-shadow: 0 10px 28px rgba(56,189,248,.14);
    }

    .modalOverlay{position:fixed; inset:0;background: rgba(0,0,0,.62);display:none;align-items:center;justify-content:center;padding:16px;z-index:999;}
    .modalOverlay.show{display:flex;}
    .modal{width:min(520px, 100%);background: rgba(2,6,23,.94);border:1px solid rgba(148,163,184,.28);border-radius:20px;box-shadow: var(--shadow);padding:14px;}
    .modal h2{font-size:1.02rem;letter-spacing:.12em;text-transform:uppercase;color: rgba(148,163,184,.95);margin-bottom:8px;}
    .q{font-size:1.0rem;font-weight:900;line-height:1.45;margin-bottom:10px;}
    .answers{display:grid; gap:10px;}
    .ans{width:100%;text-align:left;border-radius:16px;padding:.72rem .82rem;border:1px solid rgba(148,163,184,.22);background: rgba(15,23,42,.45);color: var(--text);font-weight:900;cursor:pointer;}
    .ans.good{border-color: rgba(34,197,94,.55);background: rgba(34,197,94,.10);}
    .ans.bad{border-color: rgba(239,68,68,.55);background: rgba(239,68,68,.10);}
    .modalFoot{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;color: rgba(229,231,235,.95);font-weight:900;}
    .status.good{color: #22c55e;}
    .status.bad{color: #ef4444;}
    .closeBtn{border:none;border-radius:999px;padding:.5rem .85rem;font-weight:900;background: rgba(148,163,184,.16);color: var(--text);cursor:pointer;}
  
    button, a, .toggle, .bigBtn, .wordBtn, .ans, .closeBtn{
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
      -webkit-tap-highlight-color: transparent;
    }

</style>
</head>
<body>
  <div class="app">
    <div class="top">
      <div class="brand">Physik App Â· Probespiel Â· 5er-Linien</div>
      <h1>Level 1</h1>
      <div class="sub"><b>Regel:</b> 5 gleiche Blasen in einer Linie = âœ… â†’ <b>1 Buchstabe</b>. (Waagerecht + Senkrecht + Diagonal.)</div>
      <div class="wordRow" id="wordRow"></div>
    </div>

    <div class="game">
      <div class="hud">
        <div class="pill">Buchstaben: <b id="rowsText">0</b>/11</div>
        <div class="pill">Spalten: <b id="colsText">8</b></div>
        <div class="pill">Linie: <b>5</b></div>
      </div>

      <div class="gridWrap">
        <canvas id="cv" width="360" height="600" aria-label="Spiel"></canvas>
      </div>

      <div class="hint">
        <div class="gestures">
          <div class="gesture"><span class="ic">ðŸ‘ˆðŸ‘‰</span></div>
          <div class="gesture"><span class="ic">ðŸ‘‡</span></div>
          <div class="gesture"><span class="ic">ðŸ‘†</span></div>
          <div class="gesture"><span class="ic">ðŸ”Š</span></div>
        </div>
      </div>
    </div>
  </div>

  <div class="startOverlay" id="startOverlay">
    <div class="startCard">
      <h2>Startbereit?</h2>
      <p>Ziel: Sammle Buchstaben fÃ¼r <b>MAGNETISMUS</b> durch 5er-Linien gleicher Blasen.</p>
      <div class="smallRow">
        <button class="toggle on" id="soundToggle" type="button">Sound: AN</button>
      </div>
      <div class="smallRow">
        <button class="bigBtn" id="startBtn" type="button">Start</button>
      </div>
      <p style="margin-top:10px; font-size:.85rem; color: rgba(148,163,184,.95)">
        Tipp: iPhone stumm = kein Ton (Seitenschalter).
      </p>
    </div>
  </div>

  <div class="modalOverlay" id="modal">
    <div class="modal" role="dialog" aria-modal="true">
      <h2>MAGNETISMUS</h2>
      <div class="q">Welche Aussage beschreibt Magnetismus am besten?</div>
      <div class="answers" id="answers"></div>
      <div class="modalFoot">
        <div class="status" id="status">WÃ¤hle eine Antwort.</div>
        <button class="closeBtn" id="closeBtn" type="button">SchlieÃŸen</button>
      </div>
    </div>
  </div>

  <script>

    // Prevent iOS pinch/gesture zoom inside the game
    document.addEventListener('gesturestart', (e) => e.preventDefault(), {passive:false});
    document.addEventListener('gesturechange', (e) => e.preventDefault(), {passive:false});
    document.addEventListener('gestureend', (e) => e.preventDefault(), {passive:false});

    const COLS = 8, ROWS = 10, LINE = 5;
    const TARGET = "MAGNETISMUS";
    const ALLOW_DIAGONAL = true;

    const BUBBLES = [
      {id:"MAG", icon:"ðŸ§²", hue: 145},
      {id:"ELE", icon:"âš¡", hue: 48},
      {id:"LIG", icon:"ðŸ’¡", hue: 35},
      {id:"BAT", icon:"ðŸ”‹", hue: 115},
      {id:"PL1", icon:"",   hue: 210},
      {id:"PL2", icon:"",   hue: 265},
    ];

    const QUESTIONS = {
      answers: [
        {t:"Magnetismus ist die Anziehung aller Metalle.", ok:false},
        {t:"Magnetismus ist eine Kraftwirkung zwischen bestimmten Stoffen â€“ auch ohne BerÃ¼hrung.", ok:true},
        {t:"Magnetismus entsteht nur, wenn Strom flieÃŸt.", ok:false},
        {t:"Magnetismus ist Reibung, die WÃ¤rme erzeugt.", ok:false},
      ],
      hint: "Wink: â€žKrÃ¤fte ohne BerÃ¼hrungâ€œ und nicht alle Metalle werden angezogen."
    };

    const cv = document.getElementById("cv");
    const ctx = cv.getContext("2d");
    const rowsText = document.getElementById("rowsText");
    document.getElementById("colsText").textContent = String(COLS);
    const wordRow = document.getElementById("wordRow");

    const startOverlay = document.getElementById("startOverlay");
    const startBtn = document.getElementById("startBtn");
    const soundToggle = document.getElementById("soundToggle");

    const modal = document.getElementById("modal");
    const answersEl = document.getElementById("answers");
    const statusEl = document.getElementById("status");
    const closeBtn = document.getElementById("closeBtn");

    let grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => null));
    let current = null; // {col,row,displayY,bubble}
    let desiredCol = null; // smooth target column
    let letters = 0;
    let running = false;
    let softDrop = false;
    let pausedForQuestion = false;

    let clearingCells = new Set();
    let clearUntilTs = 0;

    // ===== Sound =====
    let soundOn = true;
    let audioCtx = null;
    function ensureAudio(){
      if(!soundOn) return;
      if(!audioCtx){
        try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch(e){ audioCtx = null; }
      }
      if(audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    }
    function beep(freq=520, dur=0.06, type="sine", gain=0.06){
      if(!soundOn) return;
      ensureAudio();
      if(!audioCtx) return;
      const t0 = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = type; osc.frequency.value = freq;
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      osc.connect(g); g.connect(audioCtx.destination);
      osc.start(t0); osc.stop(t0 + dur);
    }
    const sMove  = () => beep(620, 0.035, "triangle", 0.045);
    const sDrop  = () => beep(420, 0.06,  "sine",     0.07);
    const sLock  = () => beep(300, 0.07,  "square",   0.05);
    const sClear = () => beep(760, 0.10,  "sine",     0.085);
    const sRight = () => beep(880, 0.08,  "sine",     0.10);
    const sWrong = () => beep(180, 0.09,  "sawtooth", 0.06);

    soundToggle.addEventListener("click", () => {
      soundOn = !soundOn;
      soundToggle.classList.toggle("on", soundOn);
      soundToggle.textContent = soundOn ? "Sound: AN" : "Sound: AUS";
      if(soundOn) ensureAudio();
    });

    function randBubble(){ return BUBBLES[Math.floor(Math.random()*BUBBLES.length)]; }

    function renderWord(){
      wordRow.innerHTML = "";
      for(let i=0;i<TARGET.length;i++){
        const d = document.createElement("div");
        d.className = "letter" + (i < letters ? " on" : "");
        d.textContent = (i < letters) ? TARGET[i] : "";
        wordRow.appendChild(d);
      }
      if(letters >= TARGET.length){
        const b = document.createElement("button");
        b.className = "wordBtn";
        b.textContent = TARGET;
        b.addEventListener("click", openQuestion);
        wordRow.appendChild(b);
      }
      rowsText.textContent = String(letters);
    }
    renderWord();

    function resizeCanvasToDisplay(){
      const rect = cv.getBoundingClientRect();
      const dpr = Math.min(2, window.devicePixelRatio || 1);

      // Use width as master so the grid always fits perfectly (no empty space at bottom)
      const w = Math.floor(rect.width * dpr);
      const cell = w / COLS;
      const h = Math.floor(cell * ROWS);

      if(cv.width !== w || cv.height !== h){
        cv.width = w;
        cv.height = h;
      }
    }
    function cellSize(){ return cv.width / COLS; }

    function canOccupy(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS && grid[r][c] === null; }

    function spawn(){
      const c = Math.floor(COLS/2);
      if(grid[0][c] !== null){
        reset("Game Over â€“ Feld ist voll. Neustart!");
        return;
      }
      current = {col:c, row:0, displayY:0, bubble: randBubble()};
      desiredCol = c;
    }

    function lockCurrent(){
      current.displayY = current.row;
      grid[current.row][current.col] = current.bubble;
      current = null;
      desiredCol = null;
      sLock();

      const matches = findMatches();
      if(matches.size){
        clearingCells = matches;
        clearUntilTs = performance.now() + 520;
        sClear();
      }else{
        if(!pausedForQuestion) spawn();
      }
    }

    function hardDrop(){
      if(!running || !current || pausedForQuestion || clearingCells.size) return;
      while(true){
        const nr = current.row + 1;
        if(nr < ROWS && canOccupy(nr, current.col)) current.row = nr;
        else break;
      }
      current.displayY = current.row;
      sDrop();
      lockCurrent();
    }

    function setColumnFromX(clientX){
      // Set only the target column based on finger position.
      // Actual movement happens smoothly in the main loop (max 1 column per frame).
      if(!running || !current || pausedForQuestion || clearingCells.size) return;
      const rect = cv.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width - 1, clientX - rect.left));
      desiredCol = Math.max(0, Math.min(COLS-1, Math.floor((x / rect.width) * COLS)));
    }

    // ===== Match detection (>=5 in a row, v/h/diag) =====
    function findMatches(){
      const marked = new Set();
      const addRun = (run) => { for(const [r,c] of run) marked.add(r + "," + c); };

      // horizontal
      for(let r=0;r<ROWS;r++){
        let run=[], last=null;
        for(let c=0;c<COLS;c++){
          const id = grid[r][c]?.id ?? null;
          if(id && id===last) run.push([r,c]);
          else{
            if(run.length>=LINE) addRun(run);
            run = id ? [[r,c]] : [];
            last = id;
          }
        }
        if(run.length>=LINE) addRun(run);
      }

      // vertical
      for(let c=0;c<COLS;c++){
        let run=[], last=null;
        for(let r=0;r<ROWS;r++){
          const id = grid[r][c]?.id ?? null;
          if(id && id===last) run.push([r,c]);
          else{
            if(run.length>=LINE) addRun(run);
            run = id ? [[r,c]] : [];
            last = id;
          }
        }
        if(run.length>=LINE) addRun(run);
      }

      if(ALLOW_DIAGONAL){
        // diag down-right (\)
        for(let sr=0; sr<ROWS; sr++){
          let r=sr,c=0,run=[],last=null;
          while(r<ROWS && c<COLS){
            const id = grid[r][c]?.id ?? null;
            if(id && id===last) run.push([r,c]);
            else{
              if(run.length>=LINE) addRun(run);
              run = id ? [[r,c]] : [];
              last = id;
            }
            r++; c++;
          }
          if(run.length>=LINE) addRun(run);
        }
        for(let sc=1; sc<COLS; sc++){
          let r=0,c=sc,run=[],last=null;
          while(r<ROWS && c<COLS){
            const id = grid[r][c]?.id ?? null;
            if(id && id===last) run.push([r,c]);
            else{
              if(run.length>=LINE) addRun(run);
              run = id ? [[r,c]] : [];
              last = id;
            }
            r++; c++;
          }
          if(run.length>=LINE) addRun(run);
        }

        // diag down-left (/)
        for(let sr=0; sr<ROWS; sr++){
          let r=sr,c=COLS-1,run=[],last=null;
          while(r<ROWS && c>=0){
            const id = grid[r][c]?.id ?? null;
            if(id && id===last) run.push([r,c]);
            else{
              if(run.length>=LINE) addRun(run);
              run = id ? [[r,c]] : [];
              last = id;
            }
            r++; c--;
          }
          if(run.length>=LINE) addRun(run);
        }
        for(let sc=COLS-2; sc>=0; sc--){
          let r=0,c=sc,run=[],last=null;
          while(r<ROWS && c>=0){
            const id = grid[r][c]?.id ?? null;
            if(id && id===last) run.push([r,c]);
            else{
              if(run.length>=LINE) addRun(run);
              run = id ? [[r,c]] : [];
              last = id;
            }
            r++; c--;
          }
          if(run.length>=LINE) addRun(run);
        }
      }

      return marked;
    }

    function applyClear(){
      if(!clearingCells.size) return;

      for(const key of clearingCells){
        const [rS,cS] = key.split(",");
        grid[+rS][+cS] = null;
      }

      // gravity
      for(let c=0;c<COLS;c++){
        const stack=[];
        for(let r=ROWS-1;r>=0;r--) if(grid[r][c]) stack.push(grid[r][c]);
        for(let r=ROWS-1;r>=0;r--) grid[r][c] = stack[ROWS-1-r] || null;
      }

      // letters: 1 per completed 5-run (approx by cells/5, at least 1)
      const gained = Math.max(1, Math.floor(clearingCells.size / LINE));
      letters = Math.min(TARGET.length, letters + gained);
      renderWord();

      clearingCells = new Set();

      if(letters >= TARGET.length){
        pausedForQuestion = true;
      }else{
        spawn();
      }
    }

    // ===== Drawing (no merge look) =====
    function drawGrid(){
      const s = cellSize();
      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.strokeStyle = "rgba(148,163,184,.25)";
      for(let r=0;r<=ROWS;r++){
        ctx.beginPath(); ctx.moveTo(0, r*s); ctx.lineTo(COLS*s, r*s); ctx.stroke();
      }
      for(let c=0;c<=COLS;c++){
        ctx.beginPath(); ctx.moveTo(c*s, 0); ctx.lineTo(c*s, ROWS*s); ctx.stroke();
      }
      ctx.restore();
    }

    function drawBubbleAt(cx, cy, bubble, radius, glow=1, flash=0){
      ctx.save();
      const alpha = 0.35*glow + 0.35*flash;
      ctx.shadowColor = `hsla(${bubble.hue}, 95%, 60%, ${alpha})`;
      ctx.shadowBlur = 10*glow + 14*flash;

      const g = ctx.createRadialGradient(cx - radius*0.35, cy - radius*0.35, radius*0.2, cx, cy, radius*1.1);
      g.addColorStop(0, `hsla(${bubble.hue}, 95%, ${92 + flash*6}%, 1)`);
      g.addColorStop(0.35, `hsla(${bubble.hue}, 92%, ${60 + flash*10}%, 1)`);
      g.addColorStop(1, `hsla(${bubble.hue}, 92%, 36%, 1)`);

      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.fill();

      ctx.shadowBlur = 0;
      ctx.strokeStyle = "rgba(248,250,252,.40)";
      ctx.lineWidth = Math.max(1, radius*0.06);
      ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.stroke();

      ctx.globalAlpha = 0.20 + flash*0.25;
      ctx.fillStyle = "white";
      ctx.beginPath(); ctx.arc(cx - radius*0.28, cy - radius*0.28, radius*0.20, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;

      if(bubble.icon){
        ctx.fillStyle = "rgba(2,6,23,.92)";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = `900 ${Math.floor(radius*0.90)}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
        ctx.fillText(bubble.icon, cx, cy+1);
      }
      ctx.restore();
    }

    function draw(ts=0){
      resizeCanvasToDisplay();
      ctx.clearRect(0,0,cv.width,cv.height);

      const s = cellSize();
      const radius = s*0.38;

      drawGrid();

      const flash = clearingCells.size ? (0.35 + 0.35*Math.sin(ts/80)) : 0;

      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const b = grid[r][c];
          if(!b) continue;
          const key = r + "," + c;
          const isClearing = clearingCells.has(key);
          drawBubbleAt(c*s + s/2, r*s + s/2, b, radius, 0.80, isClearing ? flash : 0);
        }
      }

      if(current){
        const lerp = 0.22;
        current.displayY = current.displayY + (current.row - current.displayY) * lerp;
        drawBubbleAt(current.col*s + s/2, current.displayY*s + s/2, current.bubble, radius, 1.10, 0);
      }
    }

    // ===== Question modal =====
    function openQuestion(){
      answersEl.innerHTML = "";
      statusEl.textContent = "WÃ¤hle eine Antwort.";
      statusEl.className = "status";
      QUESTIONS.answers.forEach(a => {
        const b = document.createElement("button");
        b.className = "ans";
        b.textContent = a.t;
        b.type = "button";
        b.addEventListener("click", () => grade(a.ok, b));
        answersEl.appendChild(b);
      });
      modal.classList.add("show");
    }
    function grade(ok, btn){
      [...answersEl.querySelectorAll("button")].forEach(x => x.disabled = true);
      if(ok){
        btn.classList.add("good");
        statusEl.textContent = "âœ… Richtig! Level abgeschlossen.";
        statusEl.className = "status good";
        sRight();
      }else{
        btn.classList.add("bad");
        statusEl.textContent = "âŒ Falsch. " + QUESTIONS.hint;
        statusEl.className = "status bad";
        sWrong();
        setTimeout(() => {
          [...answersEl.querySelectorAll("button")].forEach(x => {
            x.disabled = false;
            x.classList.remove("bad","good");
          });
          statusEl.textContent = "Versuchâ€™s nochmal.";
          statusEl.className = "status";
        }, 950);
      }
    }
    closeBtn.addEventListener("click", () => modal.classList.remove("show"));

    // ===== Input =====
    let startX=0, startY=0;
    let downSwipeActive = false;

    cv.addEventListener("pointerdown", (e) => {
      cv.setPointerCapture(e.pointerId);
      ensureAudio();
      startX = e.clientX; startY = e.clientY;
      downSwipeActive = false; softDrop = false;
      setColumnFromX(e.clientX);
    });

    cv.addEventListener("pointermove", (e) => {
      if(!running || !current || pausedForQuestion || clearingCells.size) return;
      setColumnFromX(e.clientX);
      const dy = e.clientY - startY;
      softDrop = dy > 28;
      downSwipeActive = softDrop;
    });

    cv.addEventListener("pointerup", (e) => {
      const dx = Math.abs(e.clientX - startX);
      const dy = Math.abs(e.clientY - startY);
      const isTap = dx < 10 && dy < 10 && !downSwipeActive;
      softDrop = false; downSwipeActive = false;
      if(isTap) hardDrop();
    });

    // ===== Falling (grid-true) =====
    let fallAccumulator = 0;
    function stepsPerSecond(){
      const base = 1.15;
      const bonus = Math.min(0.65, letters*0.06);
      const normal = base + bonus;
      return softDrop ? normal*6.0 : normal;
    }

    function fallStep(){
      if(!current) return;
      const nr = current.row + 1;
      if(nr < ROWS && canOccupy(nr, current.col)){
        current.row = nr;
      }else{
        lockCurrent();
      }
    }

    let lastTs = 0;
    function loop(ts){
      if(!lastTs) lastTs = ts;
      const dt = Math.min(0.033, (ts - lastTs)/1000);
      lastTs = ts;

      if(running){
        if(clearingCells.size){
          if(performance.now() >= clearUntilTs) applyClear();
        }else if(!pausedForQuestion){
          if(!current) spawn();

          // Smooth horizontal movement: at most 1 column per frame toward desiredCol
          if(current && desiredCol !== null && desiredCol !== current.col){
            const dir = Math.sign(desiredCol - current.col);
            const next = current.col + dir;
            if(canOccupy(current.row, next)){
              current.col = next;
              sMove();
            }else{
              desiredCol = current.col;
            }
          }

          fallAccumulator += stepsPerSecond() * dt;
          while(fallAccumulator >= 1){
            fallAccumulator -= 1;
            fallStep();
            if(!current) break;
          }
        }
      }

      draw(ts);
      requestAnimationFrame(loop);
    }

    function reset(msg){
      grid = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => null));
      current = null;
      desiredCol = null;
      letters = 0;
      softDrop = false;
      pausedForQuestion = false;
      fallAccumulator = 0;
      clearingCells = new Set();
      clearUntilTs = 0;
      renderWord();
      if(msg) alert(msg);
    }

    startBtn.addEventListener("click", () => {
      ensureAudio();
      startOverlay.style.display = "none";
      running = true;
      beep(520, 0.06, "sine", 0.08);
    });

    draw();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
